---
phase: 03-status-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/logPathService.ts
  - src/services/statusDetector.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "JSONL log file can be found for a given project path"
    - "Status (working/idle/blocked) can be determined from last log entry"
    - "Model type (sonnet/opus/haiku) can be extracted from log entry"
  artifacts:
    - path: "src/services/logPathService.ts"
      provides: "Log path resolution and last line reading"
      exports: ["encodeProjectPath", "findLatestLogFile", "readLastEntry"]
    - path: "src/services/statusDetector.ts"
      provides: "Status and model detection from log entries"
      exports: ["detectSessionStatus", "getSessionStatus"]
  key_links:
    - from: "src/services/statusDetector.ts"
      to: "src/services/logPathService.ts"
      via: "import { findLatestLogFile, readLastEntry }"
      pattern: "import.*logPathService"
---

<objective>
Create foundational services for JSONL log parsing and status detection.

Purpose: Enable accurate detection of Working/Idle/Blocked states and model type by parsing Claude Code's JSONL session logs.
Output: Two new services - logPathService.ts for file operations and statusDetector.ts for state logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-status-detection/03-RESEARCH.md
@.planning/phases/03-status-detection/03-CONTEXT.md

@src/stores/types.ts
@src/services/sessionBuilder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Log Path Service</name>
  <files>src/services/logPathService.ts</files>
  <action>
Create logPathService.ts with functions to locate and read Claude JSONL logs.

Implement:

1. `encodeProjectPath(projectPath: string): string`
   - Use `path.resolve()` to normalize the path
   - Encode with `Buffer.from(normalized).toString('base64url')`
   - This matches Claude's directory naming scheme

2. `findLatestLogFile(projectPath: string): string | null`
   - Build path: `~/.claude/projects/{encoded-path}/`
   - List all `.jsonl` files in directory
   - Sort by mtime descending (most recent first)
   - Return path to most recent file, or null if none found
   - Use try/catch and return null on any error (graceful degradation)

3. `readLastEntry(filePath: string): LogEntry | null`
   - Read file content with `fs.readFileSync(path, 'utf-8')`
   - Split by newline, filter empty lines
   - Try parsing last few lines (in case last line is malformed)
   - Return parsed LogEntry or null on failure

4. Define `LogEntry` interface (export it):
   ```typescript
   export interface LogEntry {
     type: 'user' | 'assistant' | 'summary';
     timestamp: string;
     message?: {
       model?: string;
       stop_reason?: 'end_turn' | 'tool_use' | 'max_tokens' | null;
       content?: Array<{ type: 'text' | 'tool_use' | 'tool_result' }>;
     };
   }
   ```

Use ESM imports with .js extensions. Import from 'fs', 'path', 'os'.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>logPathService.ts exists with encodeProjectPath, findLatestLogFile, readLastEntry exports</done>
</task>

<task type="auto">
  <name>Task 2: Create Status Detector Service</name>
  <files>src/services/statusDetector.ts</files>
  <action>
Create statusDetector.ts with state detection logic based on JSONL entries.

Implement:

1. `extractModel(modelString?: string): 'sonnet' | 'opus' | 'haiku' | null`
   - If no modelString, return null
   - Check lowercase string with includes():
     - Contains 'opus' -> return 'opus'
     - Contains 'haiku' -> return 'haiku'
     - Otherwise (includes 'sonnet' or default) -> return 'sonnet'

2. `detectStatus(entry: LogEntry, entryTime: Date): SessionStatus`
   - SessionStatus is 'working' | 'idle' | 'blocked'
   - Calculate elapsed = Date.now() - entryTime.getTime()
   - TOOL_APPROVAL_THRESHOLD_MS = 5000 (5 seconds)

   State machine logic:
   - If entry.type === 'user' -> return 'working' (Claude processing user input)
   - If entry.type === 'summary' -> return 'idle' (metadata entry)
   - For assistant entries:
     - If stop_reason === 'tool_use' AND elapsed > threshold -> return 'blocked'
     - If stop_reason === 'tool_use' AND elapsed <= threshold -> return 'working' (tool may be running)
     - If stop_reason === 'end_turn' -> return 'idle'
     - If stop_reason is null/undefined -> return 'working' (still generating)
   - Default: return 'idle'

3. `getSessionStatus(projectPath: string): { status: SessionStatus; model: ModelType }`
   - ModelType is 'sonnet' | 'opus' | 'haiku'
   - Call findLatestLogFile(projectPath)
   - If no log file, return { status: 'idle', model: 'sonnet' } (defaults)
   - Call readLastEntry(logFile)
   - If no entry, return defaults
   - Parse timestamp: new Date(entry.timestamp)
   - Call detectStatus(entry, entryTime)
   - Call extractModel(entry.message?.model) - default to 'sonnet' if null
   - Return { status, model }

Import LogEntry from './logPathService.js'. Use Session types from '../stores/types.js' for SessionStatus type alias.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>statusDetector.ts exists with getSessionStatus export that returns status and model</done>
</task>

</tasks>

<verification>
1. Both files compile without errors: `npx tsc --noEmit`
2. Services export expected functions (check with editor)
3. No runtime dependencies added (uses Node.js built-ins only)
</verification>

<success_criteria>
- logPathService.ts locates JSONL files using base64url encoding
- statusDetector.ts implements state machine from RESEARCH.md
- 5-second threshold distinguishes active tool execution from blocked state
- Model extraction handles sonnet/opus/haiku variants
- Graceful degradation: returns safe defaults when logs unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/03-status-detection/03-01-SUMMARY.md`
</output>
