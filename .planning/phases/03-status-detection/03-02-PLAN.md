---
phase: 03-status-detection
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/services/sessionBuilder.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Sessions have accurate status (working/idle/blocked) populated"
    - "Sessions have model type (sonnet/opus/haiku) populated"
    - "Blocked sessions appear at top of session list"
    - "Non-blocked sessions maintain stable ordering"
  artifacts:
    - path: "src/services/sessionBuilder.ts"
      provides: "Enriched sessions with status, model, and blocked-first sorting"
      exports: ["buildSessions", "sortSessionsWithBlocked"]
  key_links:
    - from: "src/services/sessionBuilder.ts"
      to: "src/services/statusDetector.ts"
      via: "import { getSessionStatus }"
      pattern: "import.*statusDetector"
    - from: "src/services/sessionBuilder.ts"
      to: "store.sessions"
      via: "buildSessions returns enriched Session[]"
      pattern: "return.*Session\\[\\]"
---

<objective>
Integrate status detection into session building and implement blocked-first sorting.

Purpose: Enrich detected sessions with accurate status and model from JSONL logs, then sort so blocked sessions always appear at top.
Output: Updated sessionBuilder.ts with status integration and new sorting behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-status-detection/03-CONTEXT.md
@.planning/phases/03-status-detection/03-01-SUMMARY.md

@src/stores/types.ts
@src/services/sessionBuilder.ts
@src/services/statusDetector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate Status Detection in Session Builder</name>
  <files>src/services/sessionBuilder.ts</files>
  <action>
Update buildSessions() to enrich sessions with status and model from statusDetector.

Changes:

1. Add import at top:
   ```typescript
   import { getSessionStatus } from './statusDetector.js';
   ```

2. In buildSessions(), after building the basic Session object, call getSessionStatus:
   ```typescript
   // Get status and model from JSONL logs
   const { status, model } = getSessionStatus(cwd);
   ```

3. Update the Session object creation to use detected status and model:
   - Replace `status: 'idle' as const` with `status`
   - For model: handle null from getSessionStatus by defaulting to 'sonnet'
     ```typescript
     model: model ?? 'sonnet'
     ```
   - Note: getSessionStatus returns model as `ModelType | null` where null means unknown/unreadable

4. Update lastActivity based on status:
   - If status is 'working' or 'blocked', use new Date() (recently active)
   - If status is 'idle', use new Date() (we don't have precise idle timestamp)
   - This provides a reasonable approximation for lastActivity field

The status detection happens synchronously (file reads), so no async changes needed to the map callback.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>buildSessions returns sessions with real status and model from log parsing</done>
</task>

<task type="auto">
  <name>Task 2: Implement Blocked-First Sorting</name>
  <files>src/services/sessionBuilder.ts</files>
  <action>
Create sortSessionsWithBlocked() function and update buildSessions() to use it.

1. Create new function `sortSessionsWithBlocked`:
   ```typescript
   /**
    * Sort sessions with blocked at top, then stable ordering for rest.
    * - Blocked sessions sorted by startedAt (oldest first = most urgent)
    * - Non-blocked sessions maintain stable ordering from previous cycle
    */
   export function sortSessionsWithBlocked(
     sessions: Session[],
     previousOrder: string[]
   ): Session[] {
   ```

2. Implementation:
   - Separate sessions into `blocked` and `nonBlocked` arrays
   - Sort blocked by startedAt ascending (oldest blocked first = most urgent)
   - For nonBlocked, use existing sortSessions() logic:
     - Existing sessions maintain position from previousOrder
     - New sessions added at end by startedAt
   - Return [...blocked, ...nonBlocked]

3. Keep existing `sortSessions()` function (used internally by sortSessionsWithBlocked for non-blocked sessions).

4. Update buildSessions() to call sortSessionsWithBlocked instead of sortSessions:
   ```typescript
   // Sort with blocked at top
   return sortSessionsWithBlocked(sessions, previousOrder);
   ```

This ensures blocked sessions always appear first in the list, making them impossible to miss.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>sortSessionsWithBlocked implemented, blocked sessions always sort to top</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Sessions have status field populated with working/idle/blocked
3. Sessions have model field populated with sonnet/opus/haiku
4. Blocked sessions sort to top of list (verify by code inspection)
</verification>

<success_criteria>
- Status detection integrated into session building pipeline
- Model type detected and populated for each session
- Blocked sessions always appear at top of session list
- Non-blocked sessions maintain stable ordering (existing behavior preserved)
- Graceful handling when log files are unavailable (defaults to idle/sonnet)
- Human verification checkpoint required before Plan 03-03 can proceed (non-autonomous gate)
</success_criteria>

<output>
After completion, create `.planning/phases/03-status-detection/03-02-SUMMARY.md`
</output>
