---
phase: 03-status-detection
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/hooks/status-hook.sh
  - src/services/hookStateService.ts
  - src/services/sessionBuilder.ts
autonomous: false
user_setup:
  - "User must add hook configuration to ~/.claude/settings.json after Task 1"

must_haves:
  truths:
    - "Hook script captures status transitions (working/idle/blocked)"
    - "Hook writes state to ~/.claude-hud/sessions/ per-session"
    - "HUD reads hook state files for accurate status"
    - "Status detection is event-driven, not inference-based"
  artifacts:
    - path: "src/hooks/status-hook.sh"
      provides: "Claude Code hook script for status capture"
    - path: "src/services/hookStateService.ts"
      provides: "Read hook-written state files"
      exports: ["readSessionState", "getHookBasedStatus"]
    - path: "src/services/sessionBuilder.ts"
      provides: "Updated to use hook state instead of JSONL parsing"
  key_links:
    - from: "src/services/sessionBuilder.ts"
      to: "src/services/hookStateService.ts"
      via: "import { getHookBasedStatus }"
      pattern: "import.*hookStateService"
---

<objective>
Replace JSONL-based status inference with event-driven hooks.

Background: The JSONL parsing approach (03-01, 03-02) proved unreliable due to undocumented log format variations. Hooks provide authoritative, real-time status updates directly from Claude Code.

Purpose: Get accurate working/idle/blocked status via Claude Code hooks.
Output: Hook script, state reader service, updated session builder.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key insight from research:
- UserPromptSubmit → working
- PermissionRequest → blocked
- PostToolUse → working (tool completed, still processing)
- Stop → idle

Hook receives: session_id, transcript_path, cwd, permission_mode, hook_event_name
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Status Hook Script</name>
  <files>src/hooks/status-hook.sh</files>
  <action>
Create a bash hook script that captures status transitions.

1. Create directory: `src/hooks/`

2. Create `status-hook.sh`:
```bash
#!/bin/bash
# Claude Code hook for HUD status tracking
# Writes status updates to ~/.claude-hud/sessions/

set -e

# Read hook input from stdin
INPUT=$(cat)

# Parse fields using jq (commonly available)
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
HOOK_EVENT=$(echo "$INPUT" | jq -r '.hook_event_name // empty')
CWD=$(echo "$INPUT" | jq -r '.cwd // empty')
TRANSCRIPT_PATH=$(echo "$INPUT" | jq -r '.transcript_path // empty')

# Ensure we have required fields
if [ -z "$SESSION_ID" ] || [ -z "$HOOK_EVENT" ]; then
  exit 0  # Silent exit, don't break Claude
fi

# Determine status based on hook event
case "$HOOK_EVENT" in
  UserPromptSubmit)
    STATUS="working"
    ;;
  PermissionRequest)
    STATUS="blocked"
    ;;
  PostToolUse)
    STATUS="working"
    ;;
  Stop)
    STATUS="idle"
    ;;
  *)
    # Unknown event, don't update
    exit 0
    ;;
esac

# Create state directory
STATE_DIR="$HOME/.claude-hud/sessions"
mkdir -p "$STATE_DIR"

# Extract model from transcript if available (best effort)
MODEL=""
if [ -n "$TRANSCRIPT_PATH" ] && [ -f "$TRANSCRIPT_PATH" ]; then
  # Get model from last assistant message that has one
  MODEL=$(tail -100 "$TRANSCRIPT_PATH" 2>/dev/null | grep -o '"model":"[^"]*"' | tail -1 | sed 's/"model":"//;s/"$//' || true)
  # Simplify model name
  if echo "$MODEL" | grep -qi "opus"; then
    MODEL="opus"
  elif echo "$MODEL" | grep -qi "haiku"; then
    MODEL="haiku"
  elif echo "$MODEL" | grep -qi "sonnet"; then
    MODEL="sonnet"
  else
    MODEL=""
  fi
fi

# Write state file (atomic write via temp file)
STATE_FILE="$STATE_DIR/${SESSION_ID}.json"
TEMP_FILE="$STATE_FILE.tmp.$$"

cat > "$TEMP_FILE" << EOF
{
  "status": "$STATUS",
  "model": "$MODEL",
  "cwd": "$CWD",
  "sessionId": "$SESSION_ID",
  "lastUpdate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

mv "$TEMP_FILE" "$STATE_FILE"

# Exit cleanly (don't affect Claude's behavior)
exit 0
```

3. Make executable: `chmod +x src/hooks/status-hook.sh`

Key design decisions:
- Uses jq for JSON parsing (standard tool)
- Atomic writes via temp file + mv
- Graceful degradation (exit 0 on errors)
- Model extracted from transcript as best effort
  </action>
  <verify>
1. Script has correct shebang and is executable
2. Script syntax is valid: `bash -n src/hooks/status-hook.sh`
3. jq is available: `which jq`
  </verify>
  <done>status-hook.sh created and executable</done>
</task>

<task type="checkpoint:user-setup" gate="blocking">
  <what-built>
Hook script created at src/hooks/status-hook.sh
  </what-built>
  <how-to-verify>
User must configure Claude Code to use the hook.

Add to ~/.claude/settings.json (create if doesn't exist):

```json
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "/home/ssugar/claude/cc-tui-hud/src/hooks/status-hook.sh"
          }
        ]
      }
    ],
    "PermissionRequest": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "/home/ssugar/claude/cc-tui-hud/src/hooks/status-hook.sh"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "/home/ssugar/claude/cc-tui-hud/src/hooks/status-hook.sh"
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "/home/ssugar/claude/cc-tui-hud/src/hooks/status-hook.sh"
          }
        ]
      }
    ]
  }
}
```

Note: Update the path to match actual location of status-hook.sh
  </how-to-verify>
  <resume-signal>Type "done" when hook configuration is added to settings.json</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Create Hook State Service</name>
  <files>src/services/hookStateService.ts</files>
  <action>
Create a service to read hook-written state files.

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import type { Session } from '../stores/types.js';

export interface HookSessionState {
  status: Session['status'];
  model: 'sonnet' | 'opus' | 'haiku' | null;
  cwd: string;
  sessionId: string;
  lastUpdate: string;
}

const STATE_DIR = path.join(os.homedir(), '.claude-hud', 'sessions');

/**
 * Read state file for a specific session ID
 */
export function readSessionState(sessionId: string): HookSessionState | null {
  try {
    const statePath = path.join(STATE_DIR, `${sessionId}.json`);
    if (!fs.existsSync(statePath)) {
      return null;
    }
    const content = fs.readFileSync(statePath, 'utf-8');
    const state = JSON.parse(content) as HookSessionState;
    return state;
  } catch {
    return null;
  }
}

/**
 * Find state by CWD (for sessions we detect by process but don't have hook session ID)
 */
export function findStateByPath(cwd: string): HookSessionState | null {
  try {
    if (!fs.existsSync(STATE_DIR)) {
      return null;
    }
    const files = fs.readdirSync(STATE_DIR);
    for (const file of files) {
      if (!file.endsWith('.json')) continue;
      try {
        const content = fs.readFileSync(path.join(STATE_DIR, file), 'utf-8');
        const state = JSON.parse(content) as HookSessionState;
        // Match by cwd
        if (state.cwd === cwd) {
          return state;
        }
      } catch {
        continue;
      }
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Get status and model from hook state, falling back to defaults
 */
export function getHookBasedStatus(cwd: string): {
  status: Session['status'];
  model: 'sonnet' | 'opus' | 'haiku';
} {
  const state = findStateByPath(cwd);

  if (!state) {
    // No hook data yet - default to idle/sonnet
    return { status: 'idle', model: 'sonnet' };
  }

  // Check if state is stale (older than 5 minutes = probably dead session)
  const lastUpdate = new Date(state.lastUpdate);
  const now = new Date();
  const ageMs = now.getTime() - lastUpdate.getTime();
  const STALE_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes

  if (ageMs > STALE_THRESHOLD_MS) {
    // Stale data, default to idle
    return { status: 'idle', model: state.model || 'sonnet' };
  }

  return {
    status: state.status || 'idle',
    model: state.model || 'sonnet'
  };
}
```

ESM imports with .js extension. Graceful degradation on all errors.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>hookStateService.ts created with getHookBasedStatus export</done>
</task>

<task type="auto">
  <name>Task 3: Update Session Builder to Use Hook State</name>
  <files>src/services/sessionBuilder.ts</files>
  <action>
Replace statusDetector usage with hookStateService.

1. Change import:
   - Remove: `import { getSessionStatus } from './statusDetector.js';`
   - Add: `import { getHookBasedStatus } from './hookStateService.js';`

2. In buildSessions(), update the status/model retrieval:
   - Replace: `const { status, model } = getSessionStatus(cwd);`
   - With: `const { status, model } = getHookBasedStatus(cwd);`

The rest of the code (sortSessionsWithBlocked, Session object creation) remains the same.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>sessionBuilder uses hook-based status instead of JSONL parsing</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Hooks-based status detection:
- Hook script captures UserPromptSubmit/PermissionRequest/PostToolUse/Stop events
- State files written to ~/.claude-hud/sessions/
- HUD reads state files for accurate status
  </what-built>
  <how-to-verify>
1. Start the HUD in one terminal: `npm run dev`
2. In another terminal, run a Claude Code session
3. Verify status updates in real-time:
   - When you submit a prompt → should show "working" (hourglass)
   - When Claude finishes → should show "idle" (checkmark)
   - When tool needs approval → should show "blocked" (stop sign, red background)
4. Verify model shows correctly (opus/sonnet/haiku)
5. Verify blocked sessions sort to top
  </how-to-verify>
  <resume-signal>Type "approved" if status detection works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Hook script is executable and syntactically valid
2. TypeScript compiles without errors
3. State files are written to ~/.claude-hud/sessions/ when Claude events occur
4. HUD shows accurate status based on hook events
5. Human verified: status matches real Claude state
</verification>

<success_criteria>
- Hook captures all status-relevant events
- State files written atomically (no corruption)
- HUD reads state with < 100ms latency
- Status accurately reflects Claude state (human verified)
- Graceful degradation when no hook data exists
</success_criteria>

<output>
After completion, create `.planning/phases/03-status-detection/03-04-SUMMARY.md`
</output>
