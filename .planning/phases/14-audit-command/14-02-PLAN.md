---
phase: 14-audit-command
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/cli/audit.ts
  - src/cli.tsx
autonomous: true

must_haves:
  truths:
    - "User can run vibe-term audit to scan for conflicts"
    - "Audit shows pass/warn/fail status per project with colored output"
    - "Audit displays count of issues at end"
    - "Audit returns exit code 0 when clean, 1 when failures exist"
    - "Audit can filter to show only failures with --fail-only"
    - "Audit accepts positional argument for single project or glob pattern"
  artifacts:
    - path: "src/cli/audit.ts"
      provides: "Audit command implementation"
      exports: ["runAudit", "EXIT_CODES", "AuditOptions"]
    - path: "src/cli.tsx"
      provides: "CLI routing for audit command"
      contains: "command === 'audit'"
  key_links:
    - from: "src/cli/audit.ts"
      to: "src/services/projectScanner.ts"
      via: "import and function call"
      pattern: "discoverProjects"
    - from: "src/cli/audit.ts"
      to: "src/services/conflictDetector.ts"
      via: "import and function call"
      pattern: "classifyProject"
    - from: "src/cli/audit.ts"
      to: "src/services/hookMerger.ts"
      via: "isVibeTermInstalled check"
      pattern: "isVibeTermInstalled"
    - from: "src/cli.tsx"
      to: "src/cli/audit.ts"
      via: "dynamic import"
      pattern: "import.*audit\\.js"
---

<objective>
Create the audit CLI command and integrate it into the command router.

Purpose: Users can run `vibe-term audit` to discover all Claude projects and see which ones have hook conflicts. This enables users to identify projects that need the fix command.

Output: Working audit command with table output, filtering options, and proper exit codes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-audit-command/14-CONTEXT.md
@.planning/phases/14-audit-command/14-RESEARCH.md
@.planning/phases/14-audit-command/14-01-SUMMARY.md
@src/cli/setup.ts
@src/cli/output.ts
@src/cli.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit CLI command</name>
  <files>
    - src/cli/audit.ts
  </files>
  <action>
Create `src/cli/audit.ts` following the setup.ts pattern.

**Constants:**
```typescript
export const EXIT_CODES = {
  SUCCESS: 0,
  CONFLICTS_FOUND: 1,
  ERROR: 2,
} as const;
```

**Interface:**
```typescript
export interface AuditOptions {
  failOnly: boolean;
  verbose: boolean;
  pattern?: string;  // Positional arg - glob pattern or path
}
```

**Main function `runAudit(options: AuditOptions): Promise<number>`:**

1. **Verify global hooks installed:**
   - Check settingsFileExists()
   - If not: `error('Global settings not found. Run vibe-term setup first.')` + return ERROR
   - Read settings and check isVibeTermInstalled()
   - If not: `error('vibe-term hooks not installed. Run vibe-term setup first.')` + return ERROR

2. **Discover projects:**
   - Call discoverProjects()
   - If ENOENT (no ~/.claude/projects/): `warning('No projects found. ~/.claude/projects/ does not exist.')` + return SUCCESS
   - If empty array: `info('No projects found to audit.')` + return SUCCESS

3. **Filter by pattern if provided:**
   - If options.pattern: call filterByPattern(projects, pattern)
   - If filtered result is empty: `warning('No projects match pattern: ${pattern}')` + return SUCCESS

4. **Classify each project:**
   - Loop through projects, call classifyProject() for each
   - Collect results into array

5. **Filter results if --fail-only:**
   - If failOnly: filter to only status === 'fail'

6. **Display table:**
   - Header: `dim('PATH'.padEnd(50) + 'STATUS  ISSUES')`
   - Divider: `dim('-'.repeat(70))`
   - For each result: `truncatePath(path, 48).padEnd(50) + formatStatus(status) + '      ' + issueCount`

7. **Display verbose details if requested:**
   - If verbose: after table, show each project with issues and list their specific issues

8. **Display summary line:**
   - Count pass/warn/fail
   - `Scanned ${total} projects: ${green(pass + ' pass')}, ${yellow(warn + ' warn')}, ${red(fail + ' fail')}`

9. **Return exit code:**
   - If any status === 'fail': return CONFLICTS_FOUND (1)
   - Otherwise: return SUCCESS (0)

**Helper functions:**

`formatStatus(status: ConflictStatus): string`
- pass: `green(figures.tick)`
- warn: `yellow(figures.warning)`
- fail: `red(figures.cross)`

`truncatePath(path: string, maxLen: number): string`
- If path.length <= maxLen: return path
- Otherwise: return '...' + path.slice(-(maxLen - 3))

Import from:
- `./output.js` - success, error, warning, info, green, yellow, red, dim
- `../services/settingsService.js` - readClaudeSettings, settingsFileExists
- `../services/hookMerger.js` - isVibeTermInstalled
- `../services/projectScanner.js` - discoverProjects, filterByPattern
- `../services/conflictDetector.js` - classifyProject, ProjectAuditResult, ConflictStatus
- `figures` - tick, warning, cross
- `picocolors` - (already re-exported by output.ts)
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run build` succeeds
  </verify>
  <done>
    - audit.ts exports runAudit, EXIT_CODES, and AuditOptions
    - Function checks for global hooks before scanning
    - Function displays colored table output
    - Function supports --fail-only and --verbose
    - Function returns correct exit codes
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate audit into CLI router</name>
  <files>
    - src/cli.tsx
  </files>
  <action>
Update `src/cli.tsx` to route the audit command.

**1. Update meow help text:**
```
Usage
  $ vibe-term           Launch TUI (default)
  $ vibe-term setup     Install global hooks
  $ vibe-term audit     Scan projects for conflicts

Commands
  setup     Install hooks to ~/.claude/settings.json
  audit     Scan ~/.claude/projects/ for hook conflicts

Options
  --refresh, -r  Refresh interval in seconds (default: 2)
  --yes          Skip confirmation prompts (setup only)
  --verbose, -v  Show detailed output
  --fail-only    Show only failing projects (audit only)

Examples
  $ vibe-term
  $ vibe-term setup --yes
  $ vibe-term audit
  $ vibe-term audit --fail-only
  $ vibe-term audit "**/my-project*"
```

**2. Add failOnly flag to meow flags:**
```typescript
failOnly: {
  type: 'boolean',
  default: false,
},
```

**3. Add audit command routing (after setup routing, before TUI):**
```typescript
if (command === 'audit') {
  const { runAudit } = await import('./cli/audit.js');
  const exitCode = await runAudit({
    failOnly: cli.flags.failOnly,
    verbose: cli.flags.verbose,
    pattern: cli.input[1], // Second positional arg is pattern
  });
  process.exit(exitCode);
}
```
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run build` succeeds
    - `node dist/cli.js --help` shows audit command
    - `node dist/cli.js audit` runs without crashing (may show "run setup first" if hooks not installed)
  </verify>
  <done>
    - CLI routes 'audit' command to runAudit function
    - --fail-only and --verbose flags passed correctly
    - Positional pattern argument passed as options.pattern
    - Help text documents audit command and options
  </done>
</task>

<task type="auto">
  <name>Task 3: Functional verification</name>
  <files></files>
  <action>
Build and run functional tests:

1. Build the project:
   ```bash
   npm run build
   ```

2. Test help output:
   ```bash
   node dist/cli.js --help
   ```
   Expected: Shows audit command in help

3. Test audit without setup (if hooks not installed):
   ```bash
   node dist/cli.js audit
   ```
   Expected: Error message about running setup first

4. If global hooks ARE installed (from previous setup):
   ```bash
   node dist/cli.js audit
   ```
   Expected: Table output with project status

5. Test verbose mode (if hooks installed):
   ```bash
   node dist/cli.js audit --verbose
   ```
   Expected: Table + detailed breakdown

6. Test fail-only filter:
   ```bash
   node dist/cli.js audit --fail-only
   ```
   Expected: Only shows failed projects (or empty if none fail)

Verify exit codes:
```bash
node dist/cli.js audit; echo "Exit code: $?"
```
Expected: 0 if no failures, 1 if failures exist
  </action>
  <verify>
    - Help shows audit command
    - Audit runs and produces output (table or error message)
    - Exit code is correct (0 for clean, 1 for failures)
  </verify>
  <done>
    - vibe-term audit command works end-to-end
    - Colored output displays correctly
    - Flags work as expected
    - Exit codes are CI-friendly
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm run typecheck` passes
2. `npm run build` succeeds
3. `vibe-term audit` runs and displays results (or appropriate error)
4. `vibe-term audit --fail-only` filters to only failures
5. `vibe-term audit --verbose` shows detailed breakdown
6. `vibe-term audit "**/pattern*"` filters by glob
7. Exit code 0 when clean, 1 when failures exist
</verification>

<success_criteria>
- AUDIT-01: User can run `vibe-term audit` to scan for hook conflicts
- AUDIT-02: Audit discovers projects from ~/.claude/projects/ directory
- AUDIT-03: Audit shows pass/warn/fail status per project
- AUDIT-04: Audit shows count of issues found (summary line)
- AUDIT-05: Audit returns exit code 0 for clean, 1 for issues found
- AUDIT-06: Audit lists specific conflicts found per project (in verbose mode)
- AUDIT-07: Audit filters to only show projects with conflicts (--fail-only)
- AUDIT-08: Audit groups projects by conflict type (status-based grouping in output)
</success_criteria>

<output>
After completion, create `.planning/phases/14-audit-command/14-02-SUMMARY.md`
</output>
