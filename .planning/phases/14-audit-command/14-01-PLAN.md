---
phase: 14-audit-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/projectScanner.ts
  - src/services/conflictDetector.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Projects from ~/.claude/projects/ can be discovered"
    - "Each project's originalPath is resolved from sessions-index.json"
    - "Projects can be classified as pass/warn/fail based on hooks"
    - "Malformed JSON results in fail status"
  artifacts:
    - path: "src/services/projectScanner.ts"
      provides: "Project discovery from ~/.claude/projects/"
      exports: ["discoverProjects", "DiscoveredProject"]
    - path: "src/services/conflictDetector.ts"
      provides: "Project classification (pass/warn/fail)"
      exports: ["classifyProject", "ProjectAuditResult", "ConflictStatus"]
  key_links:
    - from: "src/services/projectScanner.ts"
      to: "~/.claude/projects/*/sessions-index.json"
      via: "readFile and JSON.parse"
      pattern: "sessions-index\\.json"
    - from: "src/services/conflictDetector.ts"
      to: "$originalPath/.claude/settings*.json"
      via: "readFile and JSON.parse"
      pattern: "\\.claude/settings"
---

<objective>
Create services for discovering Claude projects and classifying hook conflicts.

Purpose: These services provide the foundation for the audit command. The projectScanner discovers all projects registered in Claude's projects directory, while the conflictDetector classifies each project's hook state (pass/warn/fail).

Output: Two TypeScript service modules that can be used by the audit CLI command.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-audit-command/14-CONTEXT.md
@.planning/phases/14-audit-command/14-RESEARCH.md
@src/services/settingsService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install micromatch and create projectScanner service</name>
  <files>
    - package.json
    - src/services/projectScanner.ts
  </files>
  <action>
1. Install micromatch and its types:
   ```bash
   npm install micromatch
   npm install -D @types/micromatch
   ```

2. Create `src/services/projectScanner.ts` with:

**Interface `DiscoveredProject`:**
```typescript
export interface DiscoveredProject {
  encodedName: string;        // Directory name in ~/.claude/projects/
  originalPath: string;       // Actual project path from sessions-index.json
  settingsPath: string | null;      // Path to .claude/settings.json if exists
  localSettingsPath: string | null; // Path to .claude/settings.local.json if exists
}
```

**Function `discoverProjects()`:**
- Read directories from `~/.claude/projects/`
- For each directory, read `sessions-index.json` and extract `originalPath`
- Check if `$originalPath/.claude/settings.json` and `$originalPath/.claude/settings.local.json` exist
- Return array of DiscoveredProject objects
- Skip directories without valid sessions-index.json (wrap in try/catch)
- Use `node:fs/promises` and `node:path` (require node: prefix for bundler)

**Function `filterByPattern(projects, pattern)`:**
- Use micromatch to filter projects by glob pattern matching originalPath
- Return filtered array
- If pattern is undefined, return all projects

**Helper `fileExists(path)`:**
- Use fs.access() with F_OK to check file existence
- Return boolean
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run build` succeeds
    - Package.json includes micromatch dependency
  </verify>
  <done>
    - projectScanner.ts exports discoverProjects, filterByPattern, and DiscoveredProject type
    - Service reads from ~/.claude/projects/ and resolves originalPath from sessions-index.json
    - Glob filtering via micromatch works
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conflictDetector service</name>
  <files>
    - src/services/conflictDetector.ts
  </files>
  <action>
1. Create `src/services/conflictDetector.ts` with:

**Type `ConflictStatus`:**
```typescript
export type ConflictStatus = 'pass' | 'warn' | 'fail';
```

**Interface `ProjectAuditResult`:**
```typescript
export interface ProjectAuditResult {
  path: string;           // originalPath
  status: ConflictStatus;
  issues: string[];       // List of specific issues found
}
```

**Function `classifyProject(projectPath, settingsPath, localSettingsPath)`:**

Classification logic per CONTEXT.md:
- **PASS**: No local hooks exist (settingsPath is null or has no hooks section)
- **WARN**: Project has hooks that can be auto-merged
- **FAIL**: Malformed JSON (parse error) or invalid structure

Implementation:
1. If settingsPath is null AND localSettingsPath is null: return PASS with empty issues
2. For each settings file that exists:
   - Try to read and JSON.parse
   - If JSON parse fails: return FAIL with issue "Malformed .claude/settings[.local].json"
   - If hooks section exists with entries: add issue "Project has [shared|local] hooks"
3. If any issues found: return WARN (hooks exist but can be merged)
4. If no issues: return PASS

Use `node:fs/promises` for file reading. Import `ClaudeSettings` type from `./settingsService.js`.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run build` succeeds
  </verify>
  <done>
    - conflictDetector.ts exports classifyProject, ProjectAuditResult, and ConflictStatus
    - Projects with no hooks return status: 'pass'
    - Projects with parseable hooks return status: 'warn' with issue details
    - Projects with malformed JSON return status: 'fail'
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm run typecheck` passes with no errors
2. `npm run build` succeeds
3. Both services export their types and functions
4. Package.json includes micromatch and @types/micromatch
</verification>

<success_criteria>
- projectScanner can discover projects from ~/.claude/projects/
- projectScanner resolves originalPath from sessions-index.json (not from directory name decoding)
- conflictDetector classifies projects correctly (pass/warn/fail)
- All code follows ESM patterns (.js imports, node: prefix for builtins)
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/14-audit-command/14-01-SUMMARY.md`
</output>
