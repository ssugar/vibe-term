---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/components/Header.tsx
  - src/components/Footer.tsx
  - src/components/EmptyState.tsx
  - src/components/SessionList.tsx
  - src/app.tsx
  - src/hooks/useInterval.ts
  - src/utils/time.ts
autonomous: true

must_haves:
  truths:
    - "Header displays title with placeholder status summary"
    - "Footer displays key hints and 'Updated Xs ago' indicator"
    - "EmptyState displays ASCII art and hint message"
    - "useInterval hook correctly updates lastRefresh in store"
  artifacts:
    - path: "src/components/Header.tsx"
      provides: "Title bar with status summary"
      exports: ["Header"]
    - path: "src/components/Footer.tsx"
      provides: "Key hints and refresh indicator"
      exports: ["Footer"]
    - path: "src/components/EmptyState.tsx"
      provides: "ASCII art for no sessions"
      exports: ["EmptyState"]
    - path: "src/components/SessionList.tsx"
      provides: "Session list placeholder (shows EmptyState)"
      exports: ["SessionList"]
    - path: "src/app.tsx"
      provides: "Main App component composing all UI"
      exports: ["default"]
    - path: "src/hooks/useInterval.ts"
      provides: "Declarative polling interval hook"
      exports: ["useInterval"]
    - path: "src/utils/time.ts"
      provides: "Relative time formatting utility"
      exports: ["formatRelativeTime"]
  key_links:
    - from: "src/app.tsx"
      to: "src/stores/appStore.ts"
      via: "useAppStore hook"
      pattern: "useAppStore"
    - from: "src/components/Footer.tsx"
      to: "src/utils/time.ts"
      via: "formatRelativeTime import"
      pattern: "formatRelativeTime"
    - from: "src/app.tsx"
      to: "src/hooks/useInterval.ts"
      via: "useInterval for polling"
      pattern: "useInterval"
---

<objective>
Build all UI components for the HUD frame: Header, Footer, EmptyState, SessionList placeholder, and the main App component that composes them.

Purpose: Create the visual structure users will see when launching the HUD. This establishes the layout patterns for all future UI work.
Output: Complete UI frame with header, content area (empty state), and footer.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Utility Hooks and Functions</name>
  <files>
    - src/hooks/useInterval.ts
    - src/utils/time.ts
  </files>
  <action>
Create utility hook and time formatting function:

1. Create src/hooks/useInterval.ts following Pattern 6 from RESEARCH.md:
   ```typescript
   import { useEffect, useRef } from 'react';

   /**
    * Declarative interval hook that handles cleanup and stale closures.
    * Pass null as delay to pause the interval.
    */
   export function useInterval(callback: () => void, delay: number | null): void {
     const savedCallback = useRef(callback);

     // Remember the latest callback
     useEffect(() => {
       savedCallback.current = callback;
     }, [callback]);

     // Set up the interval
     useEffect(() => {
       if (delay === null) return;

       const id = setInterval(() => savedCallback.current(), delay);
       return () => clearInterval(id);
     }, [delay]);
   }
   ```

2. Create src/utils/time.ts:
   ```typescript
   /**
    * Format a date as relative time (e.g., "2s ago", "1m ago", "5m ago").
    * Returns "never" if date is null.
    */
   export function formatRelativeTime(date: Date | null): string {
     if (!date) return 'never';

     const now = Date.now();
     const diff = now - date.getTime();
     const seconds = Math.floor(diff / 1000);

     if (seconds < 60) {
       return `${seconds}s ago`;
     }

     const minutes = Math.floor(seconds / 60);
     if (minutes < 60) {
       return `${minutes}m ago`;
     }

     const hours = Math.floor(minutes / 60);
     return `${hours}h ago`;
   }
   ```

These are simple utilities, so we don't need date-fns (as RESEARCH.md notes, only use if needed).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Files exist: `ls src/hooks/useInterval.ts src/utils/time.ts`
  </verify>
  <done>
    useInterval hook created with stale closure handling.
    formatRelativeTime function created for footer display.
  </done>
</task>

<task type="auto">
  <name>Task 2: UI Components</name>
  <files>
    - src/components/Header.tsx
    - src/components/Footer.tsx
    - src/components/EmptyState.tsx
    - src/components/SessionList.tsx
  </files>
  <action>
Create all UI components following Ink patterns from RESEARCH.md:

1. Create src/components/Header.tsx:
   ```typescript
   import React from 'react';
   import { Box, Text } from 'ink';
   import { useAppStore } from '../stores/appStore.js';

   export function Header(): React.ReactElement {
     const sessions = useAppStore((state) => state.sessions);

     // Count sessions by status (for later phases)
     const blocked = sessions.filter((s) => s.status === 'blocked').length;
     const working = sessions.filter((s) => s.status === 'working').length;
     const idle = sessions.filter((s) => s.status === 'idle').length;

     const hasAny = sessions.length > 0;

     return (
       <Box borderStyle="round" borderColor="blue" paddingX={1}>
         <Text bold color="cyan">Claude Code HUD</Text>
         <Text> - </Text>
         {hasAny ? (
           <>
             {blocked > 0 && <Text color="red" bold>{blocked} blocked</Text>}
             {blocked > 0 && working > 0 && <Text>, </Text>}
             {working > 0 && <Text color="yellow">{working} working</Text>}
             {(blocked > 0 || working > 0) && idle > 0 && <Text>, </Text>}
             {idle > 0 && <Text color="green">{idle} idle</Text>}
           </>
         ) : (
           <Text color="gray">No sessions</Text>
         )}
       </Box>
     );
   }
   ```

2. Create src/components/Footer.tsx:
   ```typescript
   import React from 'react';
   import { Box, Text } from 'ink';
   import figures from 'figures';
   import { useAppStore } from '../stores/appStore.js';
   import { formatRelativeTime } from '../utils/time.js';

   export function Footer(): React.ReactElement {
     const lastRefresh = useAppStore((state) => state.lastRefresh);
     const timeAgo = formatRelativeTime(lastRefresh);

     return (
       <Box
         borderStyle="round"
         borderColor="gray"
         paddingX={1}
         justifyContent="space-between"
       >
         <Text>
           <Text dimColor>j/k:</Text>
           <Text> navigate </Text>
           <Text>{figures.bullet} </Text>
           <Text dimColor>enter:</Text>
           <Text> select </Text>
           <Text>{figures.bullet} </Text>
           <Text dimColor>q:</Text>
           <Text> quit </Text>
           <Text>{figures.bullet} </Text>
           <Text dimColor>?:</Text>
           <Text> help</Text>
         </Text>
         <Text dimColor>Updated {timeAgo}</Text>
       </Box>
     );
   }
   ```

3. Create src/components/EmptyState.tsx:
   ```typescript
   import React from 'react';
   import { Box, Text } from 'ink';

   export function EmptyState(): React.ReactElement {
     return (
       <Box
         flexDirection="column"
         alignItems="center"
         paddingY={2}
       >
         <Text>
           {`  ╭──────────────────╮
  │  No Claude Code  │
  │    sessions      │
  ╰──────────────────╯`}
         </Text>
         <Box marginTop={1}>
           <Text dimColor>Start a Claude session to see it here</Text>
         </Box>
       </Box>
     );
   }
   ```

4. Create src/components/SessionList.tsx:
   ```typescript
   import React from 'react';
   import { Box } from 'ink';
   import { useAppStore } from '../stores/appStore.js';
   import { EmptyState } from './EmptyState.js';

   export function SessionList(): React.ReactElement {
     const sessions = useAppStore((state) => state.sessions);

     if (sessions.length === 0) {
       return <EmptyState />;
     }

     // Phase 2 will implement actual session rendering
     return (
       <Box flexDirection="column">
         {/* Session rows will go here */}
       </Box>
     );
   }
   ```

Note: Use `.js` extensions in all imports for ESM compatibility.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All component files exist: `ls src/components/`
    - Each exports a React component
  </verify>
  <done>
    Header component displays title and session status summary.
    Footer component displays key hints and refresh time.
    EmptyState component displays ASCII art placeholder.
    SessionList component renders EmptyState when no sessions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Main App Component</name>
  <files>
    - src/app.tsx
  </files>
  <action>
Create the main App component that composes all UI elements:

Create src/app.tsx:
```typescript
import React from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import { useAppStore } from './stores/appStore.js';
import { useInterval } from './hooks/useInterval.js';
import { Header } from './components/Header.js';
import { Footer } from './components/Footer.js';
import { SessionList } from './components/SessionList.js';

interface AppProps {
  refreshInterval: number;
}

export default function App({ refreshInterval }: AppProps): React.ReactElement {
  const { exit } = useApp();

  // Store state (selective subscriptions to prevent unnecessary re-renders)
  const isConfirmingExit = useAppStore((state) => state.isConfirmingExit);
  const showHelp = useAppStore((state) => state.showHelp);
  const error = useAppStore((state) => state.error);

  // Store actions
  const setConfirmingExit = useAppStore((state) => state.setConfirmingExit);
  const setShowHelp = useAppStore((state) => state.setShowHelp);
  const setLastRefresh = useAppStore((state) => state.setLastRefresh);
  const setRefreshInterval = useAppStore((state) => state.setRefreshInterval);

  // Set refresh interval from CLI flag
  React.useEffect(() => {
    setRefreshInterval(refreshInterval);
  }, [refreshInterval, setRefreshInterval]);

  // Polling interval - updates lastRefresh every tick
  useInterval(() => {
    setLastRefresh(new Date());
    // Phase 2 will add session detection logic here
  }, refreshInterval);

  // Handle keyboard input
  useInput((input, key) => {
    // If confirming exit, handle y/n
    if (isConfirmingExit) {
      if (input === 'y' || input === 'Y') {
        exit();
      } else {
        setConfirmingExit(false);
      }
      return;
    }

    // If showing help, any key dismisses
    if (showHelp) {
      setShowHelp(false);
      return;
    }

    // Normal mode key handling
    if (input === 'q') {
      setConfirmingExit(true);
    }
    if (input === '?') {
      setShowHelp(true);
    }
    // j/k navigation will be implemented in Phase 5
  });

  return (
    <Box flexDirection="column" padding={1}>
      <Header />

      <Box flexGrow={1} flexDirection="column" marginY={1}>
        <SessionList />
      </Box>

      <Footer />

      {/* Exit confirmation overlay */}
      {isConfirmingExit && (
        <Box
          position="absolute"
          marginTop={3}
          marginLeft={2}
        >
          <Box borderStyle="round" borderColor="yellow" paddingX={1}>
            <Text>Quit HUD? </Text>
            <Text bold color="green">y</Text>
            <Text>/</Text>
            <Text bold color="red">n</Text>
          </Box>
        </Box>
      )}

      {/* Help overlay */}
      {showHelp && (
        <Box
          position="absolute"
          marginTop={3}
          marginLeft={2}
        >
          <Box
            borderStyle="round"
            borderColor="cyan"
            flexDirection="column"
            paddingX={2}
            paddingY={1}
          >
            <Text bold color="cyan">Keyboard Shortcuts</Text>
            <Text> </Text>
            <Text><Text dimColor>j/k</Text>    Move down/up</Text>
            <Text><Text dimColor>enter</Text>  Select session</Text>
            <Text><Text dimColor>1-9</Text>    Jump to session</Text>
            <Text><Text dimColor>q</Text>      Quit</Text>
            <Text><Text dimColor>?</Text>      Toggle help</Text>
            <Text> </Text>
            <Text dimColor>Press any key to close</Text>
          </Box>
        </Box>
      )}

      {/* Error banner */}
      {error && (
        <Box
          position="absolute"
          marginTop={0}
          marginLeft={0}
        >
          <Box borderStyle="round" borderColor="red" paddingX={1}>
            <Text color="red" bold>Error: </Text>
            <Text color="red">{error}</Text>
            <Text dimColor> (x to dismiss)</Text>
          </Box>
        </Box>
      )}
    </Box>
  );
}
```

This implements:
- useInterval for polling/refresh
- q key triggers exit confirmation (per CONTEXT.md)
- ? key toggles help overlay
- Exit confirmation with y/n (per CONTEXT.md)
- Error banner display
- Selective store subscriptions (Pattern 2 from RESEARCH.md)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - src/app.tsx exists and exports default
    - App imports all components and hooks
  </verify>
  <done>
    Main App component created.
    Composes Header, SessionList (with EmptyState), Footer.
    Implements q/? key handling with overlays.
    Uses useInterval for refresh polling.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run typecheck` passes
2. All component files exist with correct exports
3. App.tsx correctly imports and uses all components
4. No unused imports or type errors
</verification>

<success_criteria>
- All UI components compile without errors
- Header shows title and "No sessions" text
- Footer shows key hints and refresh time
- EmptyState displays ASCII art
- SessionList shows EmptyState when sessions array is empty
- App component integrates all pieces with keyboard handling
- useInterval hook updates lastRefresh in store
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
