---
phase: 02-session-detection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/stores/types.ts
  - src/services/sessionBuilder.ts
  - src/utils/duration.ts
  - src/hooks/useSessions.ts
autonomous: true

must_haves:
  truths:
    - "Session type includes pid, projectName, inTmux, and tmuxTarget fields"
    - "Sessions are built from detected processes with enriched data"
    - "Duration formatting shows two units for clarity (3 hr 45 min)"
    - "useSessions hook polls for sessions and updates store"
    - "Sessions are sorted oldest-first with stable ordering"
  artifacts:
    - path: "src/stores/types.ts"
      provides: "Extended Session interface with Phase 2 fields"
      contains: "pid: number"
    - path: "src/services/sessionBuilder.ts"
      provides: "Session building from processes"
      exports: ["buildSessions", "extractProjectName", "sortSessions"]
    - path: "src/utils/duration.ts"
      provides: "Session duration formatting"
      exports: ["formatDuration"]
    - path: "src/hooks/useSessions.ts"
      provides: "Session polling hook"
      exports: ["useSessions"]
  key_links:
    - from: "src/services/sessionBuilder.ts"
      to: "src/services/processDetector.ts"
      via: "uses ClaudeProcess type"
      pattern: "import.*ClaudeProcess.*from.*processDetector"
    - from: "src/services/sessionBuilder.ts"
      to: "src/services/platform.ts"
      via: "uses getProcessCwd"
      pattern: "import.*getProcessCwd.*from.*platform"
    - from: "src/services/sessionBuilder.ts"
      to: "src/services/tmuxService.ts"
      via: "uses tmux correlation"
      pattern: "import.*from.*tmuxService"
    - from: "src/hooks/useSessions.ts"
      to: "src/services/sessionBuilder.ts"
      via: "calls buildSessions"
      pattern: "import.*buildSessions.*from.*sessionBuilder"
---

<objective>
Create session management layer that transforms raw process data into enriched Session objects with polling.

Purpose: Bridge between low-level process detection (02-01) and UI rendering (02-03) by building complete Session objects with project names, duration, and tmux context.

Output: Extended Session type, session builder service, duration formatter, and useSessions polling hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-session-detection/02-CONTEXT.md
@.planning/phases/02-session-detection/02-RESEARCH.md
@src/stores/types.ts
@src/stores/appStore.ts
@src/hooks/useInterval.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Session Type and Duration Formatter</name>
  <files>src/stores/types.ts, src/utils/duration.ts</files>
  <action>
**Update src/stores/types.ts:**

Extend Session interface with Phase 2 fields:
```typescript
export interface Session {
  id: string;                    // `claude-${pid}` for stability
  pid: number;                   // Process ID for detection
  projectPath: string;           // Full path to project
  projectName: string;           // Display name (folder or parent/folder)
  status: 'working' | 'idle' | 'blocked' | 'ended';  // Add 'ended' for fade-out
  contextUsage: number;          // 0-100 percentage (Phase 4)
  model: 'sonnet' | 'opus' | 'haiku';
  startedAt: Date;
  lastActivity: Date;
  inTmux: boolean;               // Whether running in tmux
  tmuxTarget?: string;           // e.g., "session:1.2" for navigation
}
```

**Create src/utils/duration.ts:**

Create formatDuration function per CONTEXT.md requirements:
- Under 1 minute: return "< 1 min"
- Under 1 hour: return "{N} min" (e.g., "45 min")
- Under 1 day: return "{H} hr {M} min" or "{H} hr" if M is 0
- 1+ days: return "{D} day(s) {H} hr" or "{D} day(s)" if H is 0

Use singular "day" for 1 day, plural "days" for 2+.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Session type has pid, projectName, inTmux, tmuxTarget, 'ended' status; formatDuration handles all cases</done>
</task>

<task type="auto">
  <name>Task 2: Session Builder Service</name>
  <files>src/services/sessionBuilder.ts</files>
  <action>
Create session building service that transforms processes into Sessions:

1. `extractProjectName(projectPath: string, allPaths: string[])`: Returns display name
   - Extract folder name from path (last segment)
   - Check if folder name appears in multiple paths (duplicates)
   - If duplicate, prepend parent folder: "parent/folder"
   - Otherwise return just folder name

2. `sortSessions(sessions: Session[], previousOrder: string[])`: Returns sorted sessions
   - Separate sessions into "existing" (id in previousOrder) and "new"
   - Sort existing by their position in previousOrder (maintain stability)
   - Sort new sessions by startedAt oldest-first
   - Return [...existing, ...newSessions]

3. `buildSessions(processes: ClaudeProcess[], panes: TmuxPane[], previousOrder: string[])`: Returns Promise<Session[]>
   - For each process:
     - Get cwd via getProcessCwd(pid)
     - Skip if cwd is null (process may have exited)
     - Build Session object with:
       - id: `claude-${pid}`
       - pid: process.pid
       - projectPath: cwd
       - projectName: extracted with disambiguation
       - status: 'idle' (Phase 3 will detect actual status)
       - contextUsage: 0 (Phase 4 will detect)
       - model: 'sonnet' (Phase 3 will detect)
       - startedAt: calculated from elapsedSeconds
       - lastActivity: new Date()
       - inTmux: check via isProcessInTmux
       - tmuxTarget: from tmux correlation
   - Sort sessions with previousOrder for stability

Import from: processDetector.js (ClaudeProcess), platform.js (getProcessCwd), tmuxService.js (isProcessInTmux, TmuxPane).
Export: extractProjectName, sortSessions, buildSessions.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>sessionBuilder.ts builds Session objects from processes with tmux correlation and stable sorting</done>
</task>

<task type="auto">
  <name>Task 3: useSessions Polling Hook</name>
  <files>src/hooks/useSessions.ts</files>
  <action>
Create React hook for session polling:

1. Import useEffect, useCallback, useRef from 'react'
2. Import useAppStore from stores
3. Import useInterval from ./useInterval.js
4. Import findClaudeProcesses from services/processDetector.js
5. Import getTmuxPanes from services/tmuxService.js
6. Import buildSessions from services/sessionBuilder.js

`useSessions()`: void hook that manages session detection

Implementation:
- Get refreshInterval from store
- Use useRef to track previous session order (array of IDs)
- Create refresh callback (useCallback with empty deps, use getState() for store access):
  ```typescript
  const refresh = useCallback(async () => {
    try {
      const [processes, panes] = await Promise.all([
        findClaudeProcesses(),
        getTmuxPanes(),
      ]);

      const previousOrder = previousOrderRef.current;
      const sessions = await buildSessions(processes, panes, previousOrder);

      // Update previous order for next cycle
      previousOrderRef.current = sessions.map(s => s.id);

      useAppStore.getState().setSessions(sessions);
      useAppStore.getState().setLastRefresh(new Date());
      useAppStore.getState().setError(null);
    } catch (err) {
      useAppStore.getState().setError(
        err instanceof Error ? err.message : 'Failed to detect sessions'
      );
    }
  }, []);
  ```
- Initial load via useEffect calling refresh() (with ref guard to run only once)
- Polling via useInterval(refresh, refreshInterval)

Pattern notes:
- Use useAppStore.getState() in callback to avoid stale closure issues (per Phase 1 patterns)
- Track previous order via ref to maintain stable session ordering across refreshes
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>useSessions hook polls for sessions using Phase 1's useInterval pattern with stable ordering</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` passes with no errors
2. Session type includes all new fields (pid, projectName, inTmux, tmuxTarget, 'ended' status)
3. formatDuration handles all time ranges correctly
4. sessionBuilder integrates with all three services from 02-01
5. useSessions hook follows Phase 1 patterns (getState, useInterval)
</verification>

<success_criteria>
- Session type extended with Phase 2 fields
- Duration formatting follows CONTEXT.md spec (two units, < 1 min, etc.)
- Sessions built with project name disambiguation
- Polling hook integrates detection services with store
- Stable session ordering across refreshes
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-detection/02-02-SUMMARY.md`
</output>
