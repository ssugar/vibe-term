---
phase: 15-fix-command
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/cli/fix.ts
  - src/cli.tsx
autonomous: true

must_haves:
  truths:
    - "User can run vibe-term fix to see dry-run preview"
    - "User can run vibe-term fix --apply to execute changes"
    - "User sees before/after hooks for each project"
    - "User can confirm each project individually (y/n prompt)"
    - "User can skip prompts with --yes flag"
    - "User can target specific projects with glob pattern"
    - "Exit code is 1 if any project failed"
  artifacts:
    - path: "src/cli/fix.ts"
      provides: "Fix CLI command implementation"
      exports: ["runFix", "EXIT_CODES", "FixOptions"]
    - path: "src/cli.tsx"
      provides: "CLI router with fix command"
      contains: "if (command === 'fix')"
  key_links:
    - from: "src/cli/fix.ts"
      to: "src/services/projectFixer.ts"
      via: "import generateFixPreview, applyFix"
      pattern: "import.*generateFixPreview.*projectFixer"
    - from: "src/cli/fix.ts"
      to: "src/services/projectScanner.ts"
      via: "import discoverProjects, filterByPattern"
      pattern: "import.*discoverProjects.*projectScanner"
    - from: "src/cli.tsx"
      to: "src/cli/fix.ts"
      via: "dynamic import"
      pattern: "import\\('./cli/fix.js'\\)"
---

<objective>
Create the fix CLI command and integrate into CLI router.

Purpose: Users can run `vibe-term fix` to preview hook changes (dry-run) and `vibe-term fix --apply` to execute changes with per-project confirmation. Completes the setup/audit/fix workflow.

Output: `src/cli/fix.ts` with full command implementation, updated `src/cli.tsx` with fix routing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-fix-command/15-CONTEXT.md
@.planning/phases/15-fix-command/15-RESEARCH.md
@.planning/phases/15-fix-command/15-01-SUMMARY.md

# Existing patterns to follow
@src/cli/audit.ts
@src/cli/setup.ts
@src/cli/output.ts
@src/cli.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fix CLI command</name>
  <files>src/cli/fix.ts</files>
  <action>
Create `src/cli/fix.ts` following the audit.ts pattern.

**Imports:**
```typescript
import { createInterface } from 'node:readline/promises';
import { stdin, stdout } from 'node:process';
import figures from 'figures';
import {
  success,
  error,
  warning,
  info,
  dim,
  green,
  yellow,
  cyan,
  heading,
  filePath,
} from './output.js';
import {
  readClaudeSettings,
  settingsFileExists,
} from '../services/settingsService.js';
import { isVibeTermInstalled } from '../services/hookMerger.js';
import {
  discoverProjects,
  filterByPattern,
} from '../services/projectScanner.js';
import { classifyProject } from '../services/conflictDetector.js';
import {
  generateFixPreview,
  applyFix,
  type FixPreview,
  type FixResult,
} from '../services/projectFixer.js';
```

**Exit codes:**
```typescript
export const EXIT_CODES = {
  SUCCESS: 0,
  PARTIAL_FAILURE: 1,  // Some projects failed
  ERROR: 2,            // Command couldn't run
} as const;
```

**Options interface:**
```typescript
export interface FixOptions {
  apply: boolean;       // Execute changes (vs dry-run)
  yes: boolean;         // Skip confirmation prompts
  verbose: boolean;     // Show detailed output
  pattern?: string;     // Glob pattern or path
}
```

**Helper functions:**

`truncatePath(path: string, maxLen: number): string` - Same as audit.ts

`displaySummaryTable(previews: FixPreview[]): void`
- Print heading: "Projects to fix:"
- Table header: PATH (50 chars) + MODE
- For each preview (excluding alreadyConfigured): show truncated path and mode
- Footer: count of projects to be modified

`displayBeforeAfter(preview: FixPreview): void`
- Show project path as heading
- Show settings file path (dim)
- Show mode (merge/remove-override)
- BEFORE section: JSON-stringify beforeHooks with indent, dim color
- AFTER section: JSON-stringify afterHooks with indent, cyan color
- If afterHooks is undefined: show "(hooks section removed - inherits global)"
- If beforeHooks is empty/undefined: show "(no hooks)"

`confirmProject(projectPath: string, preview: FixPreview): Promise<boolean>`
- If !stdin.isTTY, return true (auto-proceed in CI)
- Create readline interface
- Show project path
- Show mode description
- Prompt "[y/n] " (default no for safety since this modifies files)
- Accept "y", "yes" as confirmation
- Return boolean

**Main function:**
```typescript
export async function runFix(options: FixOptions): Promise<number>
```

Logic flow:
1. **Verify global hooks installed:**
   - Check settingsFileExists()
   - Read global settings, check isVibeTermInstalled()
   - If not installed: error message, return EXIT_CODES.ERROR

2. **Discover projects:**
   - Call discoverProjects()
   - Handle ENOENT (no projects dir): warning, return SUCCESS
   - If empty: info message, return SUCCESS

3. **Filter by pattern:**
   - If options.pattern: filterByPattern(projects, pattern)
   - If filtered empty: warning, return SUCCESS

4. **Find projects needing fixes:**
   - For each project, call classifyProject()
   - Keep projects where status === 'warn' AND settingsPath !== null
   - These are projects with hooks that can be merged
   - If none need fixing: info "No projects need fixing", return SUCCESS

5. **Generate previews:**
   - For each project needing fix:
     - Call generateFixPreview(originalPath, settingsPath, 'merge')
     - Default mode is 'merge' per CONTEXT.md
   - Filter out previews where alreadyConfigured === true
   - If all already configured: info message, return SUCCESS

6. **Display summary and previews:**
   - Call displaySummaryTable(previews)
   - If verbose OR !apply (dry-run): call displayBeforeAfter for each preview

7. **Dry-run exit:**
   - If !options.apply:
     - info "Dry run complete. Use --apply to execute changes."
     - return EXIT_CODES.SUCCESS

8. **Apply fixes with confirmation:**
   - const results: FixResult[] = []
   - For each preview:
     - If !options.yes: call confirmProject()
       - If declined: info "Skipped: {path}", continue to next
     - Call applyFix(settingsPath, projectPath, mode)
     - Add to results
     - If success: success message with path, info with backup path
     - If failed: error message with path and error

9. **Summary:**
   - Count successes and failures
   - Print summary line: "Fixed N project(s), M failed"

10. **Exit code:**
    - If any failed: return EXIT_CODES.PARTIAL_FAILURE
    - Else: return EXIT_CODES.SUCCESS
  </action>
  <verify>
Run `npx tsc --noEmit` - TypeScript compilation succeeds.
Run `ls src/cli/fix.ts` - file exists.
  </verify>
  <done>fix.ts created with runFix function implementing full dry-run/apply workflow with confirmation prompts.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate fix into CLI router</name>
  <files>src/cli.tsx</files>
  <action>
Update src/cli.tsx to add fix command routing.

**1. Update help text:**
Add fix command to the help string:
```
  Usage
    $ vibe-term           Launch TUI (default)
    $ vibe-term setup     Install global hooks
    $ vibe-term audit     Scan projects for conflicts
    $ vibe-term fix       Fix hook conflicts

  Commands
    setup     Install hooks to ~/.claude/settings.json
    audit     Scan ~/.claude/projects/ for hook conflicts
    fix       Fix hook conflicts in project settings
```

Add options:
```
    --apply        Execute changes (fix only, default is dry-run)
```

Add examples:
```
    $ vibe-term fix
    $ vibe-term fix --apply
    $ vibe-term fix --apply --yes
    $ vibe-term fix "**/my-project*"
```

**2. Add --apply flag to meow flags:**
```typescript
apply: {
  type: 'boolean',
  default: false,
},
```

**3. Add fix command routing after audit routing:**
```typescript
if (command === 'fix') {
  const { runFix } = await import('./cli/fix.js');
  const exitCode = await runFix({
    apply: cli.flags.apply,
    yes: cli.flags.yes,
    verbose: cli.flags.verbose,
    pattern: cli.input[1], // Second positional arg is pattern
  });
  process.exit(exitCode);
}
```

Note: --yes flag already exists (used by setup), so it's shared with fix.
  </action>
  <verify>
Run `npx tsc --noEmit` - TypeScript compilation succeeds.
Run `grep "command === 'fix'" src/cli.tsx` - routing exists.
Run `grep "apply:" src/cli.tsx` - flag exists.
  </verify>
  <done>fix command integrated into CLI router with --apply flag and pattern argument.</done>
</task>

<task type="auto">
  <name>Task 3: Functional verification</name>
  <files></files>
  <action>
Verify the fix command works end-to-end:

**1. Build the project:**
```bash
npm run build
```

**2. Test dry-run (no changes):**
```bash
./dist/cli.js fix
```
Expected:
- If no projects need fixing: "No projects need fixing."
- If projects exist: Summary table, before/after for each project, "Dry run complete."

**3. Test help includes fix:**
```bash
./dist/cli.js --help
```
Expected: Shows "fix" in commands and usage.

**4. Test unknown command still shows help:**
```bash
./dist/cli.js unknown
```
Expected: Falls through to TUI (or shows help if TUI fails).

**5. Verify exit codes (dry-run):**
```bash
./dist/cli.js fix; echo "Exit: $?"
```
Expected: Exit code 0 for dry-run success.
  </action>
  <verify>
Build succeeds: `npm run build`
fix --help shows options: `./dist/cli.js --help | grep fix`
Dry-run exits 0: `./dist/cli.js fix; echo $?` should show 0
  </verify>
  <done>Fix command builds and runs. Dry-run shows preview without modifications. Exit codes work correctly.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Build succeeds: `npm run build`
3. CLI shows fix command: `./dist/cli.js --help`
4. Dry-run works: `./dist/cli.js fix`
5. Apply flag recognized: `./dist/cli.js fix --apply --help` (or test with --yes on a test project)
</verification>

<success_criteria>
- src/cli/fix.ts exists with runFix function
- src/cli.tsx routes 'fix' command to fix.ts
- `vibe-term fix` shows dry-run preview without modifying files
- `vibe-term fix --apply` executes changes with confirmation prompts
- `vibe-term fix --apply --yes` skips prompts
- Exit code 0 for success, 1 for partial failure, 2 for error
</success_criteria>

<output>
After completion, create `.planning/phases/15-fix-command/15-02-SUMMARY.md`
</output>
