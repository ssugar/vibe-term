---
phase: 15-fix-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/projectFixer.ts
  - src/services/settingsService.ts
autonomous: true

must_haves:
  truths:
    - "generateFixPreview returns before/after hooks without modifying files"
    - "applyFix creates backup before writing changes"
    - "applyFix auto-restores from backup if written JSON is invalid"
    - "Already-configured projects are detected and skipped"
  artifacts:
    - path: "src/services/projectFixer.ts"
      provides: "Fix preview generation and application"
      exports: ["generateFixPreview", "applyFix", "FixMode", "FixPreview", "FixResult"]
  key_links:
    - from: "src/services/projectFixer.ts"
      to: "src/services/hookMerger.ts"
      via: "import mergeHooks, isVibeTermInstalled"
      pattern: "import.*mergeHooks.*hookMerger"
    - from: "src/services/projectFixer.ts"
      to: "src/services/settingsService.ts"
      via: "import formatTimestamp"
      pattern: "import.*formatTimestamp.*settingsService"
---

<objective>
Create projectFixer service for generating fix previews and applying hook changes with backup/restore.

Purpose: Provides the core fix logic (preview generation, backup, write, validate) that the fix CLI command will orchestrate. Separates concerns: service handles file operations, CLI handles user interaction.

Output: `src/services/projectFixer.ts` with preview and apply functions, minor update to settingsService to export `formatTimestamp`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-fix-command/15-CONTEXT.md
@.planning/phases/15-fix-command/15-RESEARCH.md

# Existing services to use
@src/services/hookMerger.ts
@src/services/settingsService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export formatTimestamp from settingsService</name>
  <files>src/services/settingsService.ts</files>
  <action>
Add `export` keyword to the existing `formatTimestamp` function.

Currently the function is private:
```typescript
function formatTimestamp(date: Date): string {
```

Change to:
```typescript
export function formatTimestamp(date: Date): string {
```

This allows projectFixer to use the same timestamp format for backups, ensuring consistency across all backup files.

No other changes to settingsService.ts.
  </action>
  <verify>
Run `grep "export function formatTimestamp" src/services/settingsService.ts` - should match.
Run `npx tsc --noEmit` - TypeScript compilation succeeds.
  </verify>
  <done>formatTimestamp is exported from settingsService.ts and compilation passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create projectFixer service</name>
  <files>src/services/projectFixer.ts</files>
  <action>
Create `src/services/projectFixer.ts` with the following structure:

**Imports:**
```typescript
import { readFile, writeFile, copyFile } from 'node:fs/promises';
import type { ClaudeSettings } from './settingsService.js';
import { formatTimestamp } from './settingsService.js';
import { mergeHooks, isVibeTermInstalled } from './hookMerger.js';
```

**Types:**
```typescript
export type FixMode = 'merge' | 'remove-override';

export interface FixPreview {
  projectPath: string;      // Original project path
  settingsPath: string;     // Path to settings.json being modified
  mode: FixMode;            // What operation will be performed
  beforeHooks: Record<string, unknown> | undefined;  // Hooks before fix
  afterHooks: Record<string, unknown> | undefined;   // Hooks after fix
  alreadyConfigured: boolean;  // true if vibe-term already installed
}

export interface FixResult {
  projectPath: string;
  success: boolean;
  backupPath?: string;    // Path to backup if created
  error?: string;         // Error message if failed
}
```

**generateFixPreview function:**
```typescript
export async function generateFixPreview(
  projectPath: string,
  settingsPath: string,
  mode: FixMode
): Promise<FixPreview>
```

Logic:
1. Read settingsPath, parse as JSON
2. Extract `settings.hooks` as beforeHooks
3. If mode === 'merge':
   - Check `isVibeTermInstalled(settings)` - if true, return with `alreadyConfigured: true`
   - Call `mergeHooks(settings)` to get merged settings
   - Extract merged.hooks as afterHooks
4. If mode === 'remove-override':
   - afterHooks = undefined (hooks section will be removed)
   - alreadyConfigured = false
5. Return FixPreview with all fields

**applyFix function:**
```typescript
export async function applyFix(
  settingsPath: string,
  projectPath: string,
  mode: FixMode
): Promise<FixResult>
```

Logic:
1. Create backup:
   - `const timestamp = formatTimestamp(new Date())`
   - `const backupPath = \`${settingsPath}.vibe-term-backup.${timestamp}\``
   - `await copyFile(settingsPath, backupPath)`
   - If copyFile fails, return error result

2. Read current settings:
   - `const content = await readFile(settingsPath, 'utf-8')`
   - `const settings = JSON.parse(content) as ClaudeSettings`
   - If parse fails, return error result (with backupPath)

3. Apply fix based on mode:
   - If mode === 'merge': `newSettings = mergeHooks(settings)`
   - If mode === 'remove-override':
     - `const { hooks, ...rest } = settings`
     - `newSettings = rest`

4. Write new settings:
   - `const newContent = JSON.stringify(newSettings, null, 2)`
   - `await writeFile(settingsPath, newContent, 'utf-8')`
   - If write fails, return error result

5. Validate written file (auto-restore if broken):
   - `const verifyContent = await readFile(settingsPath, 'utf-8')`
   - `JSON.parse(verifyContent)` (throws if invalid)
   - If parse fails:
     - `await copyFile(backupPath, settingsPath)` (restore from backup)
     - Return error: "Settings file corrupted after write, restored from backup"

6. Return success result with backupPath

**Error handling:**
- All file operations wrapped in try/catch
- Errors include descriptive messages
- Backup path included in result even on failure (so user knows where backup is)
  </action>
  <verify>
Run `npx tsc --noEmit` - TypeScript compilation succeeds.
Run `ls src/services/projectFixer.ts` - file exists.
  </verify>
  <done>projectFixer.ts created with generateFixPreview and applyFix functions. Types exported. All file operations have error handling.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. projectFixer.ts exports correct symbols: `grep "export" src/services/projectFixer.ts`
3. Uses existing mergeHooks (no duplicate merge logic): `grep "mergeHooks" src/services/projectFixer.ts`
4. Uses existing formatTimestamp (consistent backup naming): `grep "formatTimestamp" src/services/projectFixer.ts`
</verification>

<success_criteria>
- src/services/projectFixer.ts exists with all types and functions
- formatTimestamp exported from settingsService.ts
- TypeScript compilation passes
- No new dependencies added (uses existing project libraries)
</success_criteria>

<output>
After completion, create `.planning/phases/15-fix-command/15-01-SUMMARY.md`
</output>
