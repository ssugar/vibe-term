---
phase: 10-session-lifecycle
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useSessions.ts
  - src/services/paneSessionManager.ts
autonomous: true

must_haves:
  truths:
    - "Dead sessions (Claude process exits) are removed from HUD automatically"
    - "Panes for dead sessions are cleaned up (killed)"
    - "If active session dies, focus returns to HUD pane"
    - "Cleanup happens silently without user notification"
  artifacts:
    - path: "src/hooks/useSessions.ts"
      provides: "Session removal detection and cleanup trigger"
      contains: "previousIdsRef"
    - path: "src/services/paneSessionManager.ts"
      provides: "Pane cleanup function"
      exports: ["cleanupSessionPane"]
  key_links:
    - from: "src/hooks/useSessions.ts"
      to: "src/services/paneSessionManager.ts"
      via: "cleanupSessionPane import"
      pattern: "cleanupSessionPane"
    - from: "src/hooks/useSessions.ts"
      to: "src/stores/appStore.ts"
      via: "setActiveSessionId(null)"
      pattern: "setActiveSessionId"
---

<objective>
Implement automatic cleanup of dead sessions and their tmux panes.

Purpose: When Claude processes exit (user types /quit, session ends), the HUD should automatically remove the session from display and clean up the associated tmux pane. If the active session dies, focus should return to the HUD pane.

Output: cleanupSessionPane function in paneSessionManager, detection and cleanup logic in useSessions hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-session-lifecycle/10-RESEARCH.md
@src/hooks/useSessions.ts
@src/services/paneSessionManager.ts
@src/stores/appStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cleanupSessionPane function to paneSessionManager</name>
  <files>src/services/paneSessionManager.ts</files>
  <action>
Add new exported function to clean up a session's pane:

```typescript
/**
 * Clean up the tmux pane associated with a dead session.
 * Kills the pane and removes the environment variable mapping.
 *
 * @param sessionId - The session ID to clean up
 */
export async function cleanupSessionPane(sessionId: string): Promise<void> {
  try {
    const paneId = await getSessionPane(sessionId);
    if (!paneId) return;

    // Check if pane still exists before trying to kill
    const { stdout } = await execAsync(`tmux list-panes -a -F '#{pane_id}'`);
    if (!stdout.includes(paneId)) return;

    // Kill the pane
    await execAsync(`tmux kill-pane -t ${paneId}`);
  } catch {
    // Pane may already be gone - that's fine
  } finally {
    // Always clear the environment variable
    const envKey = sanitizeEnvKey(sessionId);
    await execAsync(`tmux set-environment -u CLAUDE_PANE_${envKey}`).catch(() => {});
  }
}
```

Export sanitizeEnvKey function (currently private, line 185) or inline it in cleanupSessionPane.
Decision: Keep sanitizeEnvKey private, just use the pattern directly in cleanupSessionPane.
  </action>
  <verify>
npm run build succeeds. Function is exported (can check with grep for "export.*cleanupSessionPane").
  </verify>
  <done>
cleanupSessionPane function exported, handles all edge cases (pane already gone, permissions errors).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session removal detection to useSessions hook</name>
  <files>src/hooks/useSessions.ts</files>
  <action>
Enhance useSessions to detect removed sessions and trigger cleanup:

1. Add import at top:
   ```typescript
   import { cleanupSessionPane } from '../services/paneSessionManager.js';
   ```

2. Add ref to track previous session IDs (after line 18):
   ```typescript
   // Track previous session IDs for removal detection
   const previousIdsRef = useRef<Set<string>>(new Set());
   ```

3. Update refresh callback to detect and clean up removed sessions:
   After line 34 (const sessions = await buildSessions(...)):
   ```typescript
   // Detect removed sessions (were in previous, not in current)
   const currentIds = new Set(sessions.map(s => s.id));
   const removedIds = [...previousIdsRef.current].filter(id => !currentIds.has(id));

   // Clean up panes for removed managed sessions (not external)
   for (const id of removedIds) {
     // Only cleanup internal sessions (external panes belong to other tmux sessions)
     const wasInternal = !id.includes('external'); // Simple heuristic, or track separately
     if (wasInternal) {
       await cleanupSessionPane(id).catch(() => {});
     }
   }

   // Update previous IDs for next cycle
   previousIdsRef.current = currentIds;
   ```

Note: The session ID format is `claude-${pid}`, so we can't distinguish internal/external from ID alone. For safety, attempt cleanup for all removed sessions - cleanupSessionPane will gracefully handle sessions without tracked panes (returns early if no paneId found).
  </action>
  <verify>
npm run build succeeds. Start a Claude session via HUD, then quit Claude with /quit - the pane should be automatically cleaned up.
  </verify>
  <done>
useSessions detects removed sessions and calls cleanupSessionPane for each.
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle active session death (focus HUD)</name>
  <files>src/hooks/useSessions.ts</files>
  <action>
When the active session dies, clear activeSessionId and focus HUD pane:

1. Add import for execAsync:
   ```typescript
   import { execAsync } from '../services/platform.js';
   ```

2. In the refresh callback, after detecting removed sessions (after cleanup loop):
   ```typescript
   // If active session was removed, clear it and focus HUD
   const activeSessionId = useAppStore.getState().activeSessionId;
   if (activeSessionId && removedIds.includes(activeSessionId)) {
     useAppStore.getState().setActiveSessionId(null);

     // Focus HUD pane
     execAsync('tmux show-environment CLAUDE_TERMINAL_HUD_PANE')
       .then(({ stdout }) => {
         const hudPaneId = stdout.split('=')[1]?.trim();
         if (hudPaneId) {
           return execAsync(`tmux select-pane -t ${hudPaneId}`);
         }
       })
       .catch(() => {}); // Ignore errors - HUD pane might not exist
   }
   ```

This ensures:
- User isn't left staring at a dead pane
- HUD becomes active so user can select another session
- Cleanup is silent (no error messages)
  </action>
  <verify>
npm run build succeeds. Manual test:
1. Spawn session with n key
2. Switch to it with Enter (becomes active)
3. Quit Claude in that session (/quit)
4. HUD should auto-focus after ~2 seconds (next polling cycle)
5. Session should disappear from tab list
  </verify>
  <done>
When active session dies, activeSessionId is cleared and HUD pane is focused.
  </done>
</task>

</tasks>

<verification>
- [ ] npm run build completes without errors
- [ ] cleanupSessionPane function exported from paneSessionManager
- [ ] Dead sessions disappear from HUD within 2-3 seconds
- [ ] Panes for dead sessions are killed (no orphan panes in scratch window)
- [ ] If active session dies, focus returns to HUD
- [ ] No error messages displayed during cleanup
</verification>

<success_criteria>
1. Sessions automatically removed when Claude process exits
2. Associated tmux panes cleaned up silently
3. Active session death handled gracefully with focus return to HUD
</success_criteria>

<output>
After completion, create `.planning/phases/10-session-lifecycle/10-03-SUMMARY.md`
</output>
